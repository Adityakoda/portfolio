"use strict";

(function (window) {
  function angleToLength(angle, length) {
    const radians = 0.017453 * Math.abs(angle); // Convert degrees to radians
    return Math.ceil(length * Math.tan(radians));
  }

  function hexToRgb(hex) {
    let result;
    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
      result = hex.substring(1).split("");
      if (result.length === 3) {
        result = [result[0], result[0], result[1], result[1], result[2], result[2]];
      }
      result = "0x" + result.join("");
      return {
        r: (result >> 16) & 255,
        g: (result >> 8) & 255,
        b: result & 255
      };
    }
    return { r: 0, g: 0, b: 0 };
  }

  class Particle {
    constructor(color, positionIndex, options) {
      this.options = options;
      this.rgb = hexToRgb(color);
      this.direction = this.randomDirection();
      this.shape = this.randomShape();
      this.size = Math.abs(this.getRandomInRange(this.options.size));
      this.setStartPosition(positionIndex);
      this.vx = this.getRandomInRange(this.options.speed.x) * this.randomDirection();
      this.vy = this.getRandomInRange(this.options.speed.y) * this.randomDirection();
    }

    setStartPosition(index) {
      const pos = this.getRandomPosition();
      switch (index) {
        case 3:
          this.x = pos.x + pos.halfWidth;
          this.y = pos.y;
          break;
        case 2:
          this.x = pos.x;
          this.y = pos.y + pos.halfHeight;
          break;
        case 1:
          this.x = pos.x + pos.halfWidth;
          this.y = pos.y + pos.halfHeight;
          break;
        default:
          this.x = pos.x;
          this.y = pos.y;
          break;
      }
    }

    getRandomPosition() {
      const width = this.options.c.w / 2;
      const height = this.options.c.h / 2;
      return {
        x: Math.random() * width,
        y: Math.random() * height,
        halfWidth: width,
        halfHeight: height
      };
    }

    getRandomInRange(range) {
      return range.min === range.max ? range.min : Math.random() * (range.max - range.min) + range.min;
    }

    randomDirection() {
      return Math.random() > 0.5 ? 1 : -1;
    }

    randomShape() {
      return this.options.shapes[Math.floor(Math.random() * this.options.shapes.length)];
    }

    rgba(color, alpha) {
      return `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
    }

    animate(ctx, canvasWidth, canvasHeight) {
      if (this.options.size.pulse) {
        this.size += this.options.size.pulse * this.direction;
        if (this.size > this.options.size.max || this.size < this.options.size.min) {
          this.direction *= -1;
        }
        this.size = Math.abs(this.size);
      }

      this.x += this.vx;
      this.y += this.vy;

      if (this.x < 0) {
        this.vx *= -1;
        this.x += 1;
      } else if (this.x > canvasWidth) {
        this.vx *= -1;
        this.x -= 1;
      }

      if (this.y < 0) {
        this.vy *= -1;
        this.y += 1;
      } else if (this.y > canvasHeight) {
        this.vy *= -1;
        this.y -= 1;
      }

      ctx.beginPath();
      if (this.options.blending && this.options.blending !== "none") {
        ctx.globalCompositeOperation = this.options.blending;
      }

      const centerColor = this.rgba(this.rgb, this.options.opacity.center);
      const edgeColor = this.rgba(this.rgb, this.options.opacity.edge);

      let radius;
      switch (this.shape) {
        case "c":
          radius = this.size / 2;
          break;
        case "t":
          radius = 0.577 * this.size;
          break;
        case "s":
          radius = 0.707 * this.size;
          break;
        default:
          radius = this.size;
      }

      const gradient = ctx.createRadialGradient(this.x, this.y, 0.01, this.x, this.y, radius);
      gradient.addColorStop(0, centerColor);
      gradient.addColorStop(1, edgeColor);
      ctx.fillStyle = gradient;

      const r = Math.abs(this.size / 2);
      switch (this.shape) {
        case "c":
          ctx.arc(this.x, this.y, r, 0, Math.PI * 2, false);
          break;
        case "s":
          ctx.moveTo(this.x - r, this.y + r);
          ctx.lineTo(this.x + r, this.y + r);
          ctx.lineTo(this.x + r, this.y - r);
          ctx.lineTo(this.x - r, this.y - r);
          break;
        case "t":
          const height = angleToLength(30, r);
          ctx.moveTo(this.x - r, this.y + height);
          ctx.lineTo(this.x + r, this.y + height);
          ctx.lineTo(this.x, this.y - 2 * height);
          break;
      }

      ctx.closePath();
      ctx.fill();
    }
  }

  class FinisherHeader {
    constructor(options) {
      this.canvas = document.createElement("canvas");
      this.ctx = this.canvas.getContext("2d");
      this.canvas.id = "finisher-canvas";
      this.getContainer(options.className).appendChild(this.canvas);

      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(this.resize.bind(this), 150);
      });

      this.init(options);
      window.requestAnimationFrame(this.animate.bind(this));
    }

    getContainer(className) {
      const containers = document.getElementsByClassName(className || "finisher-header");
      if (!containers.length) throw new Error("No .finisher-header element found");
      return containers[0];
    }

    resize() {
      const container = this.getContainer(this.options.className);
      this.options.c = {
        w: container.clientWidth,
        h: container.clientHeight
      };
      this.canvas.width = this.options.c.w;
      this.canvas.height = this.options.c.h;

      const skewOffset = angleToLength(this.options.skew, this.options.c.w / 2);
      const transform = `skewY(${this.options.skew}deg) translateY(-${skewOffset}px)`;
      this.canvas.style = `
        position: absolute;
        z-index: -1;
        top: 0; left: 0; right: 0; bottom: 0;
        transform: ${transform};
        -webkit-transform: ${transform};
        outline: 1px solid transparent;
        background-color: rgba(${this.bgColor.r}, ${this.bgColor.g}, ${this.bgColor.b}, 1);
      `;
    }

    init(options) {
      this.options = options;
      this.bgColor = hexToRgb(this.options.colors.background);
      this.particles = [];
      this.resize();
      this.createParticles();
    }

    createParticles() {
      let colorIndex = 0;
      this.particles = [];
      this.options.actualCount = window.innerWidth < 600 && this.options.count > 5
        ? Math.round(this.options.count / 2)
        : this.options.count;

      for (let i = 0; i < this.options.actualCount; i++) {
        const positionIndex = i % 4;
        const particle = new Particle(
          this.options.colors.particles[colorIndex],
          positionIndex,
          this.options
        );
        colorIndex = (colorIndex + 1) % this.options.colors.particles.length;
        this.particles.push(particle);
      }
    }

    animate() {
      window.requestAnimationFrame(this.animate.bind(this));
      this.ctx.clearRect(0, 0, this.options.c.w, this.options.c.h);
      for (const particle of this.particles) {
        particle.animate(this.ctx, this.options.c.w, this.options.c.h);
      }
    }
  }

  window.FinisherHeader = FinisherHeader;
})(window);
